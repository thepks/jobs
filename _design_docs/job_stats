{
   "_id": "_design/job_stats",
   "_rev": "141-c07c025e91b66c30f520dc508657a890",
   "language": "javascript",
   "views": {
       "status": {
           "map": "function(doc) {\n  if(doc.S && doc.owner && doc.Strtdate) { \n\n        \n        emit([doc.S, doc.Strtdate, doc.company, doc.Progtype,  doc.owner],doc.Jobname); \n  } \n}"
       },
       "job_summary": {
           "map": "function(doc) { \n\n  var prefix; \n  var suffix; \n\n  if (doc.User && doc.Progname === \"RFKK_MASS_ACT_SINGLE_JOB\" && doc.Strtdate && doc.owner) { \n\n        var underposn = doc.Jobname.lastIndexOf(\"_\"); \n        var job = doc.Jobname.slice(0,underposn);\n\tvar short_job = job.slice(0,4)+\"_\"+job.slice(12); \n        var duration = doc.Duration.split(/:/); \n        var rundate = job.slice(4,8)+\"-\"+job.slice(8,10)+\"-\"+job.slice(10,12);\n        var odate = new Date(rundate);\n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n\n        if ( doc.Strtdate && doc.Enddate) { \n                emit([short_job, odate, doc.company, doc.Progtype,  doc.owner], [doc.Strttime, doc.Endtime]); \n        } \n  } else if (doc.owner && doc.Progname && doc.Strtdate) {\n        var duration = doc.Duration.split(/:/); \n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n\n        if ( doc.Strtdate && doc.Enddate) { \n                emit([doc.Progname, doc.Strtdate, doc.company, doc.Progtype,  doc.owner], [doc.Strttime, doc.Endtime]); \n        } \n\n  }\n\n} \n",
           "reduce": "function(keys, values, rereduce) { \n\n  if (rereduce) { \n     return { \n      'start': ( function () { \n        var min; \n        min = \"2099-12-31T23:59:59.000Z\"; \n        if (!values) { return min; } \n        values.forEach( function (value) { \n                if ( value && value.start && value.start < min) { \n                                min = value.start; \n                        \n                } \n        } \n\n        ); \n\n        return min; \n     })(), \n\n      'finish': ( function () { \n        var max; \n        max = \"2000-01-01T23:59:59.000Z\"; \n        if (!values) { return max; } \n        values.forEach( function (value) { \n                if ( value && value.finish && value.finish > max) { \n                                max = value.finish; \n                        \n                } \n        } \n\n        ); \n\n        return max; \n     })(), \n\n      } \n  } else { \n    return  { \n      'start' : ( function () { \n        var min = \"2099-12-31T23:59:59.000Z\"; \n        if (values) { \n        values.forEach( function (value) { \n                if ( value && value[0] && value[0] < min) { \n                                min = value[0]; \n                        \n                }}); \n        return min;} \n        })(), \n\n     'finish' : ( function () { \n        var max = \"2000-01-01T23:59:59.000Z\"; \n        if (values) { \n        values.forEach( function (value) { \n                if ( value && value[1] && value[1] > max) { \n                                max = value[1]; \n                        \n                }}); \n        return max;} \n        })(), \n    } \n  } \n} "
       },
       "job_stats": {
           "map": "function(doc) { \n\n  var prefix; \n  var suffix; \n\n  if (doc.Progname === \"RFKK_MASS_ACT_SINGLE_JOB\" && doc.owner) { \n\n        var underposn = doc.Jobname.lastIndexOf(\"_\"); \n        var job = doc.Jobname.slice(0,underposn);\n\tvar short_job = job.slice(0,4)+\"_\"+job.slice(12); \n        var duration = doc.Duration.split(/:/); \n\tvar rundate = job.slice(4,8)+\"-\"+job.slice(8,10)+\"-\"+job.slice(10,12);\n        var odate = new Date(rundate);\n\n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n        if (isNumber(secs) ) { \n\n                emit([short_job, odate, doc.company, doc.Progtype, doc.owner], secs,'doc.CPU ms'); \n        } \n  } else if (doc.Progname && doc.Duration && doc.owner) {\n        var duration = doc.Duration.split(/:/); \n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n        if (isNumber(secs) ) { \n\n                emit([doc.Progname, doc.Strtdate,doc.company, doc.Progtype,  doc.owner], secs,'doc.CPU ms'); \n        } \n\n  } \n\n} \n\n\nfunction isNumber(n) { \n  return !isNaN(parseFloat(n)) && isFinite(n); \n} \n",
           "reduce": "_stats"
       },
       "abap_db_split": {
           "map": "function(doc) {\n    var abap_cpu_pc;\n    var abap_cpu;\n    var db_pc;\n    var db;\n    var sdt, edt;\n    \n    var elapsed;\n    var progname;\n    var odate;\n\n    if (doc.User && doc.Progname === \"RFKK_MASS_ACT_SINGLE_JOB\") {\n\n        var underposn = doc.Jobname.lastIndexOf(\"_\");\n        var job = doc.Jobname.slice(0, underposn);\n        progname = job.slice(0, 4) + \"_\" + job.slice(12);\n\tvar rundate = job.slice(4,8)+\"-\"+job.slice(8,10)+\"-\"+job.slice(10,12);\n        odate = new Date(rundate);\n\n    } else {\n        progname = doc.Progname;\n        odate = doc.Strtdate;\n    }\n\n    if (doc.Endtime) {\n        var key;\n        sdt = new Date(doc.Strttime);\n        edt = new Date(doc.Endtime);\n        elapsed = edt.getTime() - sdt.getTime();\n        key = \"CPU ms\";\n        abap_cpu = parseInt(doc[key],10);\n        key = \"DB ms\";\n        db = parseInt(doc[key],10);\n\n        emit([progname, odate, doc.company, doc.Progtype, doc.owner], {\n            'abap': abap_cpu,\n            'db': db,\n            'total': elapsed\n        });\n    }\n\n}",
           "reduce": "function(keys, values, rereduce) {\n\n   var abap = 0;\n   var db = 0;\n   var total = 0;\n\n   return {\n     'abap' : ( function () { \n         \n         abap = 0;   \n         values.forEach(function(value) {\n            abap += value.abap;\n         });\n         return abap;\n     })(),\n\n     'db' :  ( function () { \n         db = 0;\n         values.forEach(function(value) {\n            db += value.db;\n         });\n         return db;\n     })(),\n\n     'total' : ( function () { \n         total = 0;\n         values.forEach(function(value) {\n            total += value.total;\n         });\n         return total;\n     })()\n   };\n\n}"
       },
       "job_weekly_stats": {
           "map": "function(doc) { \n\n  var prefix; \n  var suffix; \n  var duration;\n  var week;\n\n  if (doc.Progname === \"RFKK_MASS_ACT_SINGLE_JOB\" && doc.owner) { \n\n        var underposn = doc.Jobname.lastIndexOf(\"_\"); \n        var job = doc.Jobname.slice(0,underposn);\n\tvar short_job = job.slice(0,4)+\"_\"+job.slice(12); \n        duration = doc.Duration.split(/:/); \n\tvar rundate = job.slice(4,8)+\"-\"+job.slice(8,10)+\"-\"+job.slice(10,12);\n        var odate = new Date(rundate);\n\tweek = calc_approx_week(odate);\n\n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n        if (isNumber(secs) ) { \n\n                emit([short_job, week,doc.company, doc.Progtype,  doc.owner], secs,'doc.CPU ms'); \n        } \n  } else if (doc.Progname && doc.Duration && doc.owner) {\n        duration = doc.Duration.split(/:/); \n\n        var secs = parseInt(duration[0])*3600+parseInt(duration[1])*60+parseInt(duration[2]); \n\n        if (isNumber(secs) ) { \n\n\t\tvar dt = new Date(doc.Strtdate);\n\t\tweek = calc_approx_week(dt);\n\n                emit([doc.Progname, week,doc.company, doc.Progtype, doc.owner], secs,'doc.CPU ms'); \n        } \n\n  } \n\n} \n\n\nfunction isNumber(n) { \n  return !isNaN(parseFloat(n)) && isFinite(n); \n} \n\nfunction calc_approx_week(dt) {\n\n\tvar yr = dt.getFullYear();\n\tvar approx_yr_start = yr+\"-01-01T00:00:00.000Z\";\n\tvar startdtsecs = Date.parse(approx_yr_start);\n\tvar dtsecs = dt.getTime();\n\n\tvar week = (dtsecs - startdtsecs) / 604800000;\n\treturn Math.floor(week);\n\n}",
           "reduce": "_stats"
       }
   },
   "lists": {
       "byuser": "function(head,req) { var results = []; var row; var roles = req.userCtx.roles; var admi = false; var requester = req.userCtx.name; for (var v=0;v<roles.length;v++) { if(roles[v] === \"_admin\" || roles[v] === \"jobadmin\"){admi=true;}} while(row=getRow()) {var user = row.key[4]; if(admi||user === requester) {results.push(row); } } var res = {}; res.rows = results; send(JSON.stringify(res)); }",
       "duration": "function(head, req) { var row; var results = []; var sdt, edt; var dur; var val = {}; var roles = req.userCtx.roles; var admi = false; var requester = req.userCtx.name; for (var v = 0; v < roles.length; v++) { if (roles[v] === \"_admin\" || roles[v] === \"jobadmin\"){admi=true;}} while (row = getRow()) { var user = row.key[4];if (admi || user === requester) { sdt = new Date(row.value.start); edt = new Date(row.value.finish); dur = edt.getTime() - sdt.getTime(); if (dur > 0) { dur = dur / 1000; } val = {}; val.key = row.key; val.value = dur; results.push(val); } } var res = {}; res.rows = results; send(JSON.stringify(res)); }",
       "proc_percentages": "function(head, req) { var abap_pc, db_pc; var results = []; var val = {}; var roles = req.userCtx.roles; var admi = false; var requester = req.userCtx.name; for (var v = 0; v < roles.length; v++) {if (roles[v] === \"_admin\" || roles[v] === \"jobadmin\"){admi=true;}} while (row = getRow()) { var user = row.key[4]; if(admi||user === requester) { abap_pc = row.value.abap / row.value.total * 100; db_pc = row.value.db / row.value.total * 100; val = {}; val.key = row.key; val.value = { 'abap': abap_pc, 'db': db_pc }; results.push(val); } } var res = {}; res.rows = results; send(JSON.stringify(res));}",
       "deg_by_week": "function(head, req) {      var val = {};     var val_togo = {};     var results = [];     var row;     var roles = req.userCtx.roles;     var admi = false;     var requester = req.userCtx.name;     for (var v = 0; v < roles.length; v++) {         if (roles[v] ===             \"_admin\" || roles[v] === \"jobadmin\") {             admi = true;         }     }      while (row = getRow()) {         var user = row.key[4];         var program = row.key[0]+\"|\"+row.key[3]+\"|\"+row.key[2];          if (admi || user === requester) {             var avg = row.value.sum / row.value.count;              if (!(program in val)) {                 val[program] = [];             }              var curr = val[program];             curr.push(avg);              val[program] = curr;          }     }      for (var keyval in val) {         var a = 0;         var b1 = 0;         var b2 = 0;         var b3 = 0;         var c = 0;         var d = 0;         var m = 0;         for (var i = 0; i < val[keyval].length; i++) {             a += val[keyval].length * ((i + 1) * val[keyval][i]);             b2 += val[keyval][i];             b1 += (i + 1);             c += (val[keyval].length * val[keyval][i] * val[keyval][i]);         }         b3 = b1 * b2;         d = b1 * b1;         m = (a - b3) / (c - d);          val_togo = {};         val_togo.key = keyval;         val_togo.value = m;         results.push(val_togo);     }      var res = {};     res.rows = results;     send(JSON.stringify(res)); }"
   }
}